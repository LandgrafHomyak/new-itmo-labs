<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Отчёт</title>
    <style>
        body {
            font-family: "Comic Sans MS"
        }
    </style>
</head>
<body>
<h1>Лабораторная работа с котиками №1</h1>
<h2>Этап 1</h2>
<i>
    Храним соответвие &lt;Имя кота&gt; → &lt;цвет, возраст, вес&gt;
    <ul>
        <li>Имя кота: <code>String</code>; служит идентификатором, id
        <li>Цвет: <code>String</code>
        <li>Возраст: <code>Int</code>
        <li>Вес: <code>Int</code>
    </ul>
    Чтобы хранить пару из ключа и значения, в одном массиве хранится ключ, в другом, по тому
    же индексу — значение.
    <br>
    Одновременно может храниться не более 1000 пар.
    <br>
    Для вхождения “Имя → цвет, возраст, вес” фиксируется формат вывода, на усмотрение
    исполнителя. Вывод вхождений осуществляется всегда в этом формате.
    <br>
    Команды для взаимодействия через CLI:
    <ul>
        <li>
            create
            <ul>
                <li>Гарантируется уникальность id, т.е. в массиве ключей не хранится ключа
                    равного id.
                <li>Формат ввода: “<code>create &lt;имя&gt; &lt;цвет&gt; &lt;возраст&gt; &lt;вес&gt;</code>”
                <li>Выводит созданное вхождение
            </ul>

        <li>
            read
            <ul>
                <li>Гарантируется корректность id, т.е. в массиве ключей точно хранится ключ
                    равный id.
                <li> Формат ввода: “<code>read &lt;имя&gt;</code>”
                <li>Выводит прочитанное вхождение
            </ul>
        <li>delete id
            <ul>
                <li>Гарантируется корректность id, т.е. в массиве ключей точно хранится ключ
                    равный id.
                <li>Формат ввода: “<code>delete &lt;имя&gt;</code>”
                <li>Выводит OK
            </ul>
        <li>readall
            <ul>
                <li>Выводит все пары ключей и значений в произвольном порядке
                <li>Формат ввода: “<code>readall</code>”
                <li>Каждое вхождение выводится с новой строки.
            </ul>
    </ul>
    По одной команде на строчке
</i>

<h3>Пример работы</h3>
<code>
    <pre>
<span style="color: blue"><b>create рыжик рыжий 12 34</b></span>
Cat: name="рыжик", color="рыжий", age=12, weight=34
<span style="color: blue"><b>create пыжик пыжий 56 78</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=78
<span style="color: blue"><b>readall</b></span>
Cat: name="рыжик", color="рыжий", age=12, weight=34
Cat: name="пыжик", color="пыжий", age=56, weight=78
<span style="color: blue"><b>read пыжик</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=78
<span style="color: blue"><b>delete рыжик</b></span>
OK
<span style="color: blue"><b>readall</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=78
</pre>
</code>
<h3>Комментарии</h3>
<ul>
    <li>
        В зависимости от подхода к оформлению кода,
        пункты про гарантию могут мешать,
        если выносить все операции в функцию:
        логично предположить что функция будет возвращать тип <code>Cat</code> (<code>not null</code>), но
        после цикла (на случай если ни одно вхождение не найдено) тоже нужно что-то возвращать (<code>null</code>)
        чтобы избежать ошибок от анализатора.
        В результате возвращаемый тип будет <code>Cat?</code>,
        что повлечёт дополнительные проверки (оператором <code>!!</code>) и места потенциальных <code>NullPointerException</code>
    </li>
    <li>
        Имя кота (ключ) дублируется в самой структуре.
        Вроде как место потенциальной ошибки, потому что ключ может не соответствовать имени, но с другой стороны удобно
        возвращать, принимать и хранить
</ul>

<h2>Этап 2</h2>

<i>
    Храним соответвие &lt;Имя кота&gt; → &lt;цвет, возраст, вес&gt;

    <ul>
        <li>Имя кота: <code>String</code>; служит идентификатором
        <li>Цвет: <code>String</code>
        <li>Возраст: <code>Int</code>
        <li>Вес: <code style="color:red"><b>Float</b></code>
    </ul>
    Чтобы хранить пару из ключа и значения, храним в связном списке пары из имени кота и data class’а, соответствующего
    значению &lt;цвет, возраст, вес&gt;
    <br>
    Одновременно может храниться любое количество пар.
    <br>
    Для вхождения “Имя → цвет, возраст, вес” фиксируется формат вывода, на усмотрение исполнителя. Вывод вхождений
    осуществляется всегда в этом формате.
    <br>
    Команды для взаимодействия через CLI:

    <ul>
        <li>create
            <ul>
                <li><b>Не гарантируется уникальность id</b>, т.е. в списке необязательно <u>хранится</u><sup>отсутствует?</sup>
                    пара, в которой первый компонент равен
                    id.
                <li>Формат ввода: “<code>create &lt;имя&gt; &lt;цвет&gt; &lt;возраст&gt; &lt;вес&gt;</code>”
                <li>Выводит созданное вхождение или сообщение об ошибке “<code>Create: already exists</code>”
            </ul>
        <li>read
            <ul>
                <li><b>Не гарантируется</b> корректность id, т.е. в списке необязательно хранится пара, в которой первый
                    компонент равен
                    id.
                <li> Формат ввода: “<code>read &lt;имя&gt;</code>”
                <li>Выводит прочитанное вхождение или сообщение об ошибке “<code>Read: not found</code>”
            </ul>
        <li>delete id
            <ul>
                <li>
                    <b>Не гарантируется</b> корректность id, т.е. в списке необязательно хранится пара, в которой первый
                    компонент равен
                    id.
                <li>Формат ввода: “<code>delete &lt;имя&gt;</code>”
                <li>Выводит “<code>OK</code>” или сообщение об ошибке “<code>Delete: not found</code>”
            </ul>
        <li>
            readall
            <ul>
                <li>Выводит все пары ключей и значений в произвольном порядке
                <li>Формат ввода: “<code>readall</code>”
                <li>Каждое вхождение выводится с новой строки.
            </ul>
    </ul>

    По одной команде на строчке.
</i>

<h3>Пример работы</h3>
<code>
    <pre>
<span style="color: blue"><b>read рыжик</b></span>
Read: not found
<span style="color: blue"><b>create рыжик рыжий 12 34.5</b></span>
Cat: name="рыжик", color="рыжий", age=12, weight=34.5
<span style="color: blue"><b>create рыжик рыжий 12 34.5</b></span>
Create: already exists
<span style="color: blue"><b>delete пыжик</b></span>
Delete: not found
<span style="color: blue"><b>create пыжик пыжий 67 89.0</b></span>
Cat: name="пыжик", color="пыжий", age=67, weight=89.0
<span style="color: blue"><b>readall</b></span>
Cat: name="рыжик", color="рыжий", age=12, weight=34.5
Cat: name="пыжик", color="пыжий", age=67, weight=89.0

</pre>
</code>
<h3>Комментарии</h3>
<ul>
    <li>
        Аналогично неоднозначность с хранением имени в двух местах
    <li>
        Переход к <code>Float</code> не влияет вообще ни на что, поэтому команду можно "where weight" можно перенести из
        3 этапа, во 2
    <li>
        Из текста задания не ясно, нужно ли использовать <code>LinkedList&lt;Cat&gt;</code> или писать свой (довольно
        полезный/интересный опыт)
</ul>


<h2>Этап 3</h2>

<i>
    Храним соответвие &lt;Имя кота&gt; → &lt;цвет, возраст, вес&gt;

    <ul>
        <li>Имя кота: <code>String</code>; служит идентификатором
        <li>Цвет: <code>String</code>
        <li>Возраст: <code>Int</code>
        <li>Вес: <code>Float</code>
    </ul>

    Чтобы хранить пару из ключа и значения, храним в таблице пары из имени кота и data class’а, соответствующего
    значению &lt;цвет, возраст, вес&gt;
    <br>
    Хэш-таблица реализована как массив со связными списками пар.
    <br>
    Одновременно может храниться любое количество пар.
    <br>
    Алгоритм хэширования — на выбор студента.
    <br>
    Для вхождения “Имя → цвет, возраст, вес” фиксируется формат вывода, на усмотрение исполнителя. Вывод вхождений
    осуществляется всегда в этом формате.
    <br>
    Команды для взаимодействия через CLI:
    <br>
    <ul>
        <li>
            create
            <ul>
                <li>
                    **Не гарантируется уникальность id,** т.е. в списке не обязательно хранится пара, в которой первый
                    компонент равен
                    id.
                <li>
                    Формат ввода: “<code>create &lt;имя&gt; &lt;цвет&gt; &lt;возраст&gt; &lt;вес&gt;</code>”
                <li>
                    Выводит созданное вхождение
            </ul>
        <li>
            read
            <ul>
                <li>
                    **Не гарантируется** корректность id, т.е. в списке не обязательно хранится пара, в которой первый
                    компонент равен
                    id.
                <li>
                    Формат ввода: “<code>read &lt;имя&gt;</code>”
                <li>
                    Выводит прочитанное вхождение
            </ul>
        <li>
            update id
            <ul>
                <li>
                    **Не гарантируется** корректность id, т.е. в списке не обязательно хранится пара, в которой первый
                    компонент равен
                    id.
                <li>
                    Формат ввода: “<code>update &lt;имя&gt; &lt;цвет&gt; &lt;возраст&gt; &lt;вес&gt;</code>”
                <li>
                    Выводит прочитанное вхождение
            </ul>
        <li>
            delete id
            <ul>
                <li>
                    **Не гарантируется** корректность id, т.е. в списке не обязательно хранится пара, в которой первый
                    компонент
                    равен
                    id.
                <li>
                    Формат ввода: “<code>delete &lt;имя&gt;</code>”
                <li>
                    Выводит “<code>OK</code>”
            </ul>
        <li>
            where weight=&lt;value&gt;
            <ul>
                <li>
                    Выводит все вхождения где вес кота равен value с <code>epsilon = 0.001</code>
                <li>
                    Формат ввода: “<code>where weight=&lt;value&gt;</code>”
            </ul>
        <li>
            readall
            <ul>
                <li>
                    Выводит все пары ключей и значений в произвольном порядке
                <li>
                    Формат ввода: “<code>readall</code>”
                <li>
                    Каждое вхождение выводится с новой строки.
            </ul>
    </ul>
    По одной команде на строчке.
</i>

<h3>Пример работы</h3>
<code>
    <pre>
<span style="color: blue"><b>create рыжик рыжий 12 34.5</b></span>
Cat: name="рыжик", color="рыжий", age=12, weight=34.5
<span style="color: blue"><b>create пыжик пыжий 67 89.0</b></span>
Cat: name="пыжик", color="пыжий", age=67, weight=89.0
<span style="color: blue"><b>readall</b></span>
Cat: name="пыжик", color="пыжий", age=67, weight=89.0
Cat: name="рыжик", color="рыжий", age=12, weight=34.5
<span style="color: blue"><b>update чижик чижый 0 0</b></span>
Update: not found
<span style="color: blue"><b>create чижик чижий 12 0.001</b></span>
Cat: name="чижик", color="чижий", age=12, weight=0.001
<span style="color: blue"><b>update рыжик рыжий 34 0.002</b></span>
Cat: name="рыжик", color="рыжий", age=34, weight=0.002
<span style="color: blue"><b>update пыжик пыжий 56 0.003</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=0.003
<span style="color: blue"><b>readall</b></span>
Cat: name="чижик", color="чижий", age=12, weight=0.001
Cat: name="пыжик", color="пыжий", age=56, weight=0.003
Cat: name="рыжик", color="рыжий", age=34, weight=0.002
<span style="color: blue"><b>where weight=0.002</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=0.003
Cat: name="рыжик", color="рыжий", age=34, weight=0.002
<span style="color: blue"><b>where weight=0.00199999</b></span>
Cat: name="чижик", color="чижий", age=12, weight=0.001
Cat: name="рыжик", color="рыжий", age=34, weight=0.002
</pre>
</code>
<h3>Комментарии</h3>
<ul>
    <li>
        Аналогично неоднозначность с хранением имени в двух местах
    <li>
        В update не указано, что делать если ключ не найден (вывести сообщение об ошибке)
    <li>
    У команды <code>where weight</code> немного перегруженный синтаксис, если её переносить во 2 этап, то оставить про <code>weight=&lt;Float&gt;</code>, а в третьем тогда сделать полноценный <code>select</code> по всем полям (но только на полное равенство) с переменным числом аргументов. Звучит сложно, но в итоге реализация простая (в файле <code>src/database.kt</code> закомментирована функция <code>printSelectedRecords</code>).
</ul>


</body>
</html>