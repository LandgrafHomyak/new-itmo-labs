<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Отчёт</title>
    <style>
        body {
            font-family: "Comic Sans MS"
        }
    </style>
</head>
<body>
<h1>Лабораторная работа с котиками №1</h1>
<h2>Этап 1</h2>
<i>
    Храним соответвие &lt;Имя кота&gt; → &lt;цвет, возраст, вес&gt;
    <ul>
        <li>Имя кота: <code>String</code>; служит идентификатором, id
        <li>Цвет: <code>String</code>
        <li>Возраст: <code>Int</code>
        <li>Вес: <code>Int</code>
    </ul>
    Чтобы хранить пару из ключа и значения, в одном массиве хранится ключ, в другом, по тому
    же индексу — значение.
    <br>
    Одновременно может храниться не более 1000 пар.
    <br>
    Для вхождения “Имя → цвет, возраст, вес” фиксируется формат вывода, на усмотрение
    исполнителя. Вывод вхождений осуществляется всегда в этом формате.
    <br>
    Команды для взаимодействия через CLI:
    <ul>
        <li>
            create
            <ul>
                <li>Гарантируется уникальность id, т.е. в массиве ключей не хранится ключа
                    равного id.
                <li>Формат ввода: “<code>create &lt;имя&gt; &lt;цвет&gt; &lt;возраст&gt; &lt;вес&gt;</code>”
                <li>Выводит созданное вхождение
            </ul>

        <li>
            read
            <ul>
                <li>Гарантируется корректность id, т.е. в массиве ключей точно хранится ключ
                    равный id.
                <li> Формат ввода: “<code>read &lt;имя&gt;</code>”
                <li>Выводит прочитанное вхождение
            </ul>
        <li>delete id
            <ul>
                <li>Гарантируется корректность id, т.е. в массиве ключей точно хранится ключ
                    равный id.
                <li>Формат ввода: “<code>delete &lt;имя&gt;</code>”
                <li>Выводит OK
            </ul>
        <li>readall
            <ul>
                <li>Выводит все пары ключей и значений в произвольном порядке
                <li>Формат ввода: “<code>readall</code>”
                <li>Каждое вхождение выводится с новой строки. По одной команде на строчке
            </ul>
    </ul>
</i>

<h3>Пример работы</h3>
<code>
    <pre>
<span style="color: blue"><b>create рыжик рыжий 12 34</b></span>
Cat: name="рыжик", color="рыжий", age=12, weight=34
<span style="color: blue"><b>create пыжик пыжий 56 78</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=78
<span style="color: blue"><b>readall</b></span>
Cat: name="рыжик", color="рыжий", age=12, weight=34
Cat: name="пыжик", color="пыжий", age=56, weight=78
<span style="color: blue"><b>read пыжик</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=78
<span style="color: blue"><b>delete рыжик</b></span>
OK
<span style="color: blue"><b>readall</b></span>
Cat: name="пыжик", color="пыжий", age=56, weight=78
</pre>
</code>
<h3>Комментарии</h3>
<ul>
    <li>
        В зависимости от подхода к оформлению кода,
        пункты про гарантию могут мешать,
        если выносить все операции в функцию:
        логично предположить что функция будет возвращать тип <code>Cat</code> (<code>not null</code>), но
        после цикла (на случай если ни одно вхождение не найдено) тоже нужно что-то возвращать (<code>null</code>)
        чтобы избежать ошибок от анализатора.
        В результате возвращаемый тип будет <code>Cat?</code>,
        что повлечёт дополнительные проверки (оператором <code>!!</code>) и места потенциальных <code>NullPointerException</code></li>
    <li>
        Имя кота (ключ) дублируется в самой структуре.
        Вроде как место потенциальной ошибки, потому что ключ может не соответствовать имени, но с другой стороны удобно возвращать, принимать и хранить
</ul>
</body>
</html>